# 线性基函数回归
给定满足函数关系的一组训练样本{(x_1,y_1 ),…,(x_N,y_N )},N=300,使用线性基函数模型拟合函数y=f(x)。
## 1.模型
线性基函数回归，广义的非线性模型可以写为多个非线性基函数的线性组合。
## 2.学习准则
经验风险最小化
## 3.优化算法
梯度下降算法
## 4.评价指标
预测值与真实值的标准差
## 5.程序代码
```
#加载函数库
import numpy as np
import matplotlib.pyplot as plt

#生成偏置的函数
def identity_basis(x):
    ret = np.expand_dims(x, axis=1)
    return ret

#多项式基函数
def multinomial_basis(x, feature_num=10):
    x = np.expand_dims(x, axis=1) # shape(N, 1)
    feat = [x]
    for i in range(2, feature_num+1):
        feat.append(x**i)
    ret = np.concatenate(feat, axis=1)
    return ret
    
#高斯基函数
def gaussian_basis(x, feature_num=10):
    centers = np.linspace(0, 25, feature_num)
    width = 1.0 * (centers[1] - centers[0])
    x = np.expand_dims(x, axis=1)
    x = np.concatenate([x]*feature_num, axis=1)
    out = (x-centers)/width
    ret = np.exp(-0.5 * out ** 2)
    return ret

#加载数据函数
def load_data(filename, basis_func=gaussian_basis):
    xys = []
    with open(filename, 'r') as f:
        for line in f:
            xys.append(map(float, line.strip().split()))
        xs, ys = zip(*xys)
        xs, ys = np.asarray(xs), np.asarray(ys)
        
        o_x, o_y = xs, ys
        phi0 = np.expand_dims(np.ones_like(xs), axis=1)
        phi1 = basis_func(xs)
        xs = np.concatenate([phi0, phi1], axis=1)
        return (np.float32(xs), np.float32(ys)), (o_x, o_y)

#加载tensorflow库
import tensorflow as tf
from tensorflow.keras import optimizers, layers, Model

#定义模型类
#定义模型初始化函数
class linearModel(Model):
    def __init__(self, ndim):
        super(linearModel, self).__init__()
        self.w = tf.Variable(
            shape=[ndim, 1], 
            initial_value=tf.random.uniform(
                [ndim,1], minval=-0.1, maxval=0.1, dtype=tf.float32))
        
    @tf.function
    def call(self, x):
        y = tf.squeeze(tf.matmul(x, self.w), axis=1)
        return y

#加载训练集数据
#优化算法：梯度下降法
(xs, ys), (o_x, o_y) = load_data('train.txt')        
ndim = xs.shape[1]
model = linearModel(ndim=ndim)
optimizer = optimizers.Adam(0.1)
@tf.function
def train_one_step(model, xs, ys):
    with tf.GradientTape() as tape:
        y_preds = model(xs)
        loss = tf.reduce_mean(tf.sqrt(1e-12+(ys-y_preds)**2))
    grads = tape.gradient(loss, model.w)
    optimizer.apply_gradients([(grads, model.w)])
    return loss

#定义预测函数
@tf.function
def predict(model, xs):
    y_preds = model(xs)
    return y_preds

#定义评价函数：标准差
def evaluate(ys, ys_pred):
    std = np.sqrt(np.mean(np.abs(ys - ys_pred) ** 2))
    return std

#迭代次数
for i in range(2000):
    loss = train_one_step(model, xs, ys)
    if i % 100 == 1:
        print(f'loss is {loss:.4}')

#计算训练集数据预测的输出值
#使用评价函数输出标准差
y_preds = predict(model, xs)
std = evaluate(ys, y_preds)
print('训练集预测值与真实值的标准差：{:.1f}'.format(std))

#计算测试集数据预测的输出值
#使用评价函数输出标准差
(xs_test, ys_test), (o_x_test, o_y_test) = load_data('test.txt')
y_test_preds = predict(model, xs_test)
std = evaluate(ys_test, y_test_preds)
print('训练集预测值与真实值的标准差：{:.1f}'.format(std))

#显示结果
plt.plot(o_x, o_y, 'ro', markersize=3)
plt.plot(o_x_test, y_test_preds, 'k')
plt.xlabel('x')
plt.ylabel('y')
plt.title('Linear Regression')
plt.legend(['train', 'test', 'pred'])
plt.show()
```
